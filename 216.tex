\documentclass{article}
\usepackage{setup}
\begin{document}

\section*{Propositional Logic}
\subsection{Definitions}

\begin{itemize}
\item Implication: When P is true, Q must be true. False implies true.
\item $P \implies Q \equiv \neg P \lor Q$
\item If $\sigma$ is an assignment and $\varphi$ is a formula, then $\sigma \models \varphi$ (sigma satisfies phi) means $\varphi$ is true under assignment $\sigma$.
\item A formula $\varphi$ is satisfiable if there exists an assignment $\sigma$ such that $\sigma \models \varphi$. Otherwise, we say it's unsatisfiable.
\item A formula is valid (aka a tautology) if for every assignment $\sigma$, $\sigma \models \varphi$.
\item Two formulas $\varphi$ and $\psi$ are logically equivalent, denoted $\varphi \equiv \psi$, if for every assignment $\sigma$, $\sigma \models \varphi$ iff $\sigma \models \psi$.
\item Formulas $\varphi$ and $\psi$ are equisatisfiable if $\varphi$ is satisfiable iff $\psi$ is satisfiable.
\end{itemize}

\subsection{The Boolean Satisfiability Problem (SAT)}
\begin{itemize}
\item Given a propositional formula $\varphi$, is $\varphi$ satisfiable?
\item Example: System M with input x and output y and an input-output specification $\varphi(x, y)$. If we can encode the computation of M as a formula $\psi_m(x,y)$ such that this formula holds iff y is the output of M on input x ($\psi_m$ is called the input-output relation or transition relation of M), then we can decide whether M satisfies $\varphi$ for all inputs using this formula: \[\chi = \psi_m(x, y) \land \neg \varphi(x, y)\] The formula is satisfiable iff $M\not\models \varphi$, ie there is some input x such that M violates $\varphi$ on that input. So to verify M, we can check if $\chi$ is unsatisfiable.
\item Usually when we refer to SAT, we are referring to the CNF-SAT problem, where the input formula is in conjunctive normal form (CNF).
\item A formula is in CNF if it is a conjunction of clauses, where each clause is a disjunction (OR) of literals, and a literal is either a variable or the negation of a variable. Example: \[(x_1 \lor \neg x_2 \lor x_3) \land (\neg x_1 \lor x_4) \land (x_2 \lor x_3 \lor \neg x_4)
\]
\item The top level operator must be an AND.
\item Any formula can be converted to CNF.
\item A useful transformation is the Tseitin transformation, which converts any formula $\varphi$ to an equisatisfiable CNF formula $\psi$ in linear time. The idea is to introduce a new variable for each subformula of $\varphi$ and add clauses that enforce the equivalence between the new variable and the subformula. Example: \begin{align*}
\varphi = \neg(x\lor y)\lor(\neg z\land x) \\
\text{List the cases for the clause (gate) (call the output the clause u):} \\
x\implies \neg u \\
y\implies \neg u \\
\neg x \land \neg y \implies u \\
\text{Using demorgans law, we can rewrite these as:} \\
\neg x \lor \neg u \\
\neg y \lor \neg u \\
x \lor y \lor u\\
\text{AND them all together to represent the first gate!} \\
(\neg x \lor \neg u) \land (\neg y \lor \neg u) \land (x \lor y \lor u)
\end{align*}
These three clauses uniquely determine u given values for x and y (among satisfying assignments). Repeating this for every gate in the circuit gives a set of clauses encoding how the whole circuit works. Then add one more clause asserting that the output wire is true. Now any satisfying assignment of the original formula can be extended to one satisfying the new formula, and conversely any satisfying assignment of the new formula satisfies the original.
\item Since there is 1 gate per boolean operator, and a constant number of clauses per gate, the new CNF formula has size linear in the size of the original formula.
\item Disjunctive Normal Form (DNF) is the dual of CNF, where the top level operator is OR and each cube is an AND of literals. Example: \[(x_1 \land \neg x_2 \land x_3) \lor (\neg x_1 \land x_4) \lor (x_2 \land x_3 \land \neg x_4)\]
\item DNF is always satisfiable unless every cube is contradictory (eg $x_1 \land \neg x_1$).
\item SAT is solvable in linear time for DNF.
\item There is no efficient way to convert an arbitrary formula to DNF.
\end{itemize}

\subsection{Binary Decision Diagrams (BDDs)}

\begin{itemize}
\item It's a representation of boolean functions as graphs that allows varius operations (in particular, satisfiability) to be done efficiently but is more compact than a truth table.
\item A BDD is a directed acyclic graph (DAG) with: \begin{itemize}
    \item A designated root node
    \item Leaf nodes will be labeled true or false
    \item Internal nodes will be labeled with a variable and have two outgoing edges, one for the case where the variable is true and one for false.
\end{itemize}
\item The BDD for iff looks like:
\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node[circle, draw] (x1) {$x_1$};
    \node[circle, draw, below left of=x1] (x2) {$x_2$};
    \node[circle, draw, below right of=x1] (x3) {$x_2$};
    \node[rectangle, draw, below left of=x2] (t) {T};
    \node[rectangle, draw, below right of=x2] (f) {F};
    \node[rectangle, draw, below left of=x3] (f2) {F};
    \node[rectangle, draw, below right of=x3] (t2) {T};
    \draw[->] (x1) -- node {0} (x2);
    \draw[->] (x1) -- node {1} (x3);
    \draw[->] (x2) -- node {0} (t);
    \draw[->] (x2) -- node {1} (f);
    \draw[->] (x3) -- node {0} (f2);
    \draw[->] (x3) -- node {1} (t2);
\end{tikzpicture}
\end{center}
\item Given a variable assignment, follow the corresponding edges until you reach a leaf. The value of the function is the label of the leaf.
\item Every boolean function can be represented by a BDD.
\end{itemize}

\subsection*{Reduced Ordered BDDs (ROBDDs)}
\begin{itemize}
    \item Ordered: The variables must be accessed according to a specified order along every branch of the BDD. Skipping is okay, but you cannot repeat them. An example BDD that is not ordered:
    \begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node[circle, draw] (x1) {$x_1$};
    \node[circle, draw, below left of=x1] (x2) {$x_2$};
    \node[circle, draw, below right of=x1] (x3) {$x_1$};
    \node[rectangle, draw, below left of=x2] (t) {T};
    \node[rectangle, draw, below right of=x2] (f) {F};
    \node[rectangle, draw, below left of=x3] (f2) {F};
    \node[rectangle, draw, below right of=x3] (t2) {T};
    \draw[->] (x1) -- node {0} (x2);
    \draw[->] (x1) -- node {1} (x3);
    \draw[->] (x2) -- node {0} (t);
    \draw[->] (x2) -- node {1} (f);
    \draw[->] (x3) -- node {0} (f2);
    \draw[->] (x3) -- node {1} (t2);
\end{tikzpicture}
\end{center}
    \item Reduced: No duplicate nodes/leaves or redundant nodes. A node is redundant if both its edges point to the same node.
    \item There is only one unique ROBDD for a given boolean function.
    \item You can check if two functions are equivalent by checking if their ROBDDs are identical.
    \item The size of the unique ROBDD for a given function can be very different depending on the variable ordering.
    \item How to build a ROBDD: Build a truth table, then build the fully expanded BDD, then reduce it.
    \item Second approach: Build from a formula in a recursive bottom-up manner by applying boolean operations. Given ROBDDs for formulas $\varphi$ and $\psi$, we can build the ROBDD for $\varphi \land \psi, \varphi \lor \psi, \neg \varphi$, etc.
    
    To do this, we'll use Shannon Expansion (aka Boole's Law), which expands a boolean function in terms of one of its variables. 

    $F(x,\cdots, x_n) \iff (x_1\land F(T, x_2, \cdots, x_n)) \lor (\neg x_1 \land F(F, x_2, \cdots, x_n))$

    \item $F(T, x_2,\cdots, x_n)$ is the positive cofactor of F with respect to $x_1$. Written $F_{x_1}(x_2, \cdots, x_n)$. \\$F(F, x_2, \cdots, x_n)$ is the negative cofactor of F with respect to $x_1$. Written $F_{\bar{x_1}}(x_2, \cdots, x_n)$.
    \item You can get the cofactors of a BDD by following the appropriate edges.
    \item Every node of the BDD corresponds to the cofactor of F with respect to the assignments leading to that node.
    \item The cofactors of the AND of two functions are the AND of the cofactors. E.g. \begin{align*}
    F(x, y) &= H(x, y) \land G(x, y) \\
    F_x(y) &= F(T, y) = H(T, y) \land G(T, y) = H_x(y) \land G_x(y) \\
    F_{\bar{x}}(y) &= F(F, y) = H(F, y) \land G(F, y) = H_{\bar{x}}(y) \land G_{\bar{x}}(y)
    \end{align*}
    It's the same for OR, NOT, etc.
    \item Extisential quantification: $\exists x_1.\varphi(x_1, \cdots, x_n) \iff \varphi(T, x_2, \cdots, x_n) \lor \varphi(F, x_2, \cdots, x_n)$
    \item Universal quantification: $\forall x_1.\varphi(x_1, \cdots, x_n) \iff \varphi(T, x_2, \cdots, x_n) \land \varphi(F, x_2, \cdots, x_n)$
    \item There are boolean functions with $n$ variables whose ROBDDs (even with the best variable ordering) have size exponential in n.
    \item Idea: Counting argument. There are $2^{2^n}$ distinct boolean functions on n variables, but fewer BDDs with less than exponential nodes.
\end{itemize}
\subsection*{Queries on BDDs}
\begin{itemize}
\item Does a given assignment/input satisfy hte formula? (Linear, simply plug into the BDD).
\item You can check satisfiability and validity in constant time. Simply check if the ROBDD is just a single true or false leaf.
\item Are two formulas equivalent? (Linear, check if the ROBDDs are identical).
\item How many satisfying assignments are there? Idea: think about all paths from the root to the true leaf.
\end{itemize}

\section*{SAT Solving}
\begin{itemize}
    \item Motivation: Avoid BDD blowup by trading time for memory. SAT solvers don't run out of memory, but they may search for a long time.
    \item SAT is NP-complete. All known algorithms for SAT take more than polynomial time in the worst case. But this does not rule out practical algorithms.
    \item NP-completeness doesn't imply that all SAT problems take exponential time. There are some special cases which are solvable efficiently.
    \begin{itemize}
        \item Horn clauses: CNF-SAT. Each clause has at most one positive literal. E.g. \[(\neg x_1 \lor \neg x_2 \lor x_3) \land (\neg x_2 \lor \neg x_3) \land (x_1) \land (\neg x_1 \lor x_3)\]
        This is equivalent to implications whose left hand sides are conjunctions of variables. E.g. \[(x_1 \land x_2 \implies x_3) \land (x_2 \land x_3 \implies \text{false}) \land (\text{true} \implies x_1) \land (x_1 \implies x_3)\]
        \item 2SAT: CNF-SAT where each clause has at most 2 literals. E.g. \[(x_1 \lor \neg x_2) \land (\neg x_2 \lor x_3) \land (\neg x_1 \lor x_3) \land (\neg x_1 \lor \neg x_3)\]
    \end{itemize}
    \item For general SAT, there are heuristic algorithms that tend to work well in practice even though their runtimes are exponential in the worst case.
    \item We'll look at search algorithms which the space of assignment looking for a satisfying assignment.
    \item Simplest approach: Check all $2^n$ assignments by brute force. Guaranteed to take exponential time if the formula is UNSAT.
    \item Better way: Search through partial assignments, pruning away parts of the space that can't possibly satisfy the formula.
    \item First algorithm: Backtracking search. Divide and conquer. Split the space on some variable, assign it to true and false respectively (reducing the number of variables by 1). Solve those subproblems recursively. If $x=F$ doesn't work, backtrack by undoing that assignment and trying $x=T$ instead.
    \item DPLL algorithm: Backtracking search with better formula simplification during search.
   \item Unit propagation: A clause with only one literal (a unit clause) forces a variable to be true/false. Clauses can become unit after a partial assignment. You then don't split on the remaining variable, you simply assign it accordingly and continue. Then we can propagate this assignment to potentially force further assignments. (Note: $T\lor\neg y$ is not considered a unit since it is already satisfied.) If UP yields a contradiction this is a conflict: An assignment might falsify a conflicting clause.
    \item Pure literal elimination: If a variable appears with only one polarity (always negated or always unnegated) in the formula, it can be assigned to satisfy all those clauses and removed from the formula. E.g. in \[(x_1 \lor \neg x_2) \land (\neg x_2 \lor x_3) \land (\neg x_1 \lor x_3) \land (\neg x_1 \lor \neg x_3) \land (x_4 \lor x_1)\] $x_4$ is a pure literal and can be set to true and removed.
    \item DPLL algorithm summary:
    \begin{enumerate}
        \item $\varphi \leftarrow$ simplify($\varphi$). Apply UP and PLE until reaching a fixpoint.
        \item If we encountered a conflict, return UNSAT.
        \item If $\varphi$ is empty (all clauses satisfied), return SAT.
        \item Pick a variable $x$ in $\varphi$.
        \item If DPLL($\varphi\land x$) = SAT, return SAT.
        \item If DPLL($\varphi\land \neg x$) = SAT, return SAT.
        \item Return UNSAT.
    \end{enumerate}
    Correctness: $\varphi$ is satisfiable iff either $\varphi\land x$ or $\varphi\land \neg x$ is satisfiable.
    \item Issues: Keeping track of different simplified formulas. Finding unit clauses efficiently (naive implementation would have to scan every clause wherever we make an assignment). Can encounter the same conflict many times, searching parts of the space that can't possibly work.
    \item Solution: Learn a clause after each conflict that eliminates the partial assignment which led to the conflict (the reason for the conflict). Later, this ``conflict clause'' (here $x_1\lor x_1000$) will trigger unit propagation before we would hit the same conflict again.
\end{itemize}

\section*{Conflict-driven clause learning (CDCL) algorithm.}

\begin{itemize}
    \item Notation: Assigning a value to a unassigned variable when there is no UP left to do is called a decision. All assigned variables during the search are either decision variables or implied by UP. The decision level (DL) of a variable is the depth of the search tree when it was assigned.
    \item We'll write $\neg x_5 @ 7$ to mean $x_5$ was assigned false at decision level 7.
\end{itemize}

\end{document}